The paths module
================

	>>> import paths

We'll need the os module for some of the tests below

	>>> import os

The pwd() method is a synonym for os.getcwd()

	>>> start_here = paths.pwd()
	>>> start_here == os.getcwd()
	True

The cd() method (at least) calls os.chdir()
It returns True if the change of directory is successful

	>>> paths.cd('/no/such/path')
	False
	>>> paths.pwd() == '/usr/lib'
	False
	>>> paths.cd('/usr/lib')
	True
	>>> paths.pwd()
	<DirectPath u'/usr/lib'>

cd() recognises the special value '-' to go back to the previous directory

	>>> paths.cd('-') and paths.pwd() == start_here or 'fail'
	True

If a cd() fails the value used gets ignored for going back
	>>> paths.cd('/no/such/path') and paths.pwd() or 'fail'
	'fail'
	>>> paths.cd('-') and paths.pwd() or 'fail'
	<DirectPath u'/usr/lib'>

Calling using '-' repeatedly will toggle between two directories:

	>>> paths.cd('/usr')
	True
	>>> paths.cd('/home')
	True
	>>> for i in range(0,4):
	...    _ = paths.cd('-')
	...    print paths.pwd()
	/usr
	/home
	/usr
	/home

If the path to a file is given, cd() will change to that file's parent directory

	>>> paths.cd('/bin/cp')
	True
	>>> paths.pwd() == '/bin'
	True

DirectPath
----------

A class called DirectPath is also supplied, which extends the path class, slightly.
You can construct an instance of DirectPath directly:

	>>> p = paths.DirectPath('.')

Or by using the method makepath

	>>> p = makepath('.')

The difference is that makepath expands the string given
	>>> paths.DirectPath('~/..')[0] == '~'
	True
	>>> makepath('~/..')[0] == '/'
	True

DirectPath is ako string, which shows the string in %s and %r

	>>> bin = paths.DirectPath('/bin')
	>>> print '%s' % bin
	/bin
	>>> print '%r' % bin
	<DirectPath u'/bin'>

Path expansion at creation
--------------------------

The makepath method expands paths "normally"
	So both of these end up with the same (string) value:
	>>> direct_home = paths.DirectPath(os.environ['HOME'])
	>>> path_to_home = makepath('~')
	>>> direct_home == path_to_home
	True
	
And that is an expanded path
	>>> path_to_home.startswith('/') and '~' not in path_to_home
	True

The same works for the value if concatenation was applied to the path
	or is applied to the string
	>>> path_to_bashrc = makepath('~/.bashrc')
	>>> path_to_home / '.bashrc' == path_to_bashrc
	True

We are expecting ~/.bashrc to exist,
	so the types should also be the same: both are FilePaths
	>>> type(path_to_home / '.bashrc') == type(path_to_bashrc)
	True

cd
--

DirectPath adds the cd() method, which cd's to the path it represents
It calls the module level cd() method with its own value, so it works as above.

	>>> p = makepath('/bin/cp')
	>>> p.cd()
	True
	>>> paths.pwd() == '/bin'
	True
	>>> f = paths.DirectPath('/bin')
	>>> f.cd() and paths.pwd() or 'fail'
	<DirectPath u'/bin'>

DirectPath vs path
------------------

Using the / operator on a DirectPath or path gives an instance of the same class
	>>> from path import path
	>>> home = path('~')
	>>> bashrc = home / '.bashrc'
	>>> type(bashrc)
	<class 'path.path'>

	>>> home = paths.DirectPath('~')
	>>> bashrc = home / '.bashrc'
	>>> type(bashrc)
	<class 'paths.DirectPath'>

Attributes of a DirectPath should also be DirectPaths (should not be path)
	>>> type(bashrc.parent)
	<class 'paths.DirectPath'>

The split_all_ext method
------------------------

	>>> p = paths.FilePath('/alan/was/here.tar.gz')
	>>> p.splitext()
	(<FilePath u'/alan/was/here.tar'>, u'.gz')
	>>> p.split_all_ext()
	(<FilePath u'/alan/was/here'>, u'.tar.gz')


Whether sub_paths exist
-----------------------

This test assumes you have a ~/bin directory
	Also assumes you have a ~/.bashrc file, which is more likely
	>>> sub_paths = [ '.bashrc', 'bin', 'not a real path' ]
	>>> real_paths = paths.home().existing_sub_paths(sub_paths)
	>>> show(real_paths)
	[<FilePath u'/.../.bashrc'>, <DirectPath u'/.../bin'>]

Iteration of paths
------------------

Iterating a directory gives directory entries (sub-directories and files)
	>>> '.bashrc' in [p.name for p in paths.home() if p.isfile()]
	True

Iterating a file gives lines
	>>> p = paths.home() / '.bashrc'
	>>> print [l for l in p if 'source' in l][0]
	source ...
